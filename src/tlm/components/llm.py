from typing import Any, Callable, Optional
from dataclasses import dataclass
import json
import re

from ..base import Instance, InstanceId, Label


@dataclass
class LLMResult:
    """
    Contains all information relevant to recording the output of a particular LLM on a
    particular QA instance.

    instance_id: Unique identifier of the QA instance that prompted the generated text.
    generated_text: Text generated by the LLM.
    logprobs: Whatever data structure each API uses to return logprob information.
    """

    instance_id: InstanceId
    generated_text: str
    logprobs: Optional[Any] = None


class LLM:
    def __init__(self, model_name: str):
        """
        Interface for all LLMs.

        :param model_name: A unique name for this LLM to differentiate it from others.
        """
        self.model_name = model_name

    def __call__(self, text: str, instance: Instance, *args, **kwargs) -> LLMResult:
        """
        Returns an LLMResult based on the given input text and Instance.

        :param text: Input text. Format may vary depending on upstream parameters.
        :param instance: The Instance associated with this input text.
        """
        raise NotImplementedError


class LLMOutputParser:
    def __call__(
        self,
        generated_text: str,
        instance: Instance,
        *args,
        **kwargs,
    ) -> Optional[Label]:
        """
        Parses the generated_text of an LLM to extract an answer Label based on the
        answer choices from the given Instance. Returns None on parsing failure.
        """
        raise NotImplementedError


class PatternMatchLLMOutputParser(LLMOutputParser):
    def __init__(
        self,
        pattern_format: str,
        match_label: bool = True,
        match_term: bool = True,
        comparator: Callable[[str, str], bool] = lambda x, y: x.lower() == y.lower(),
        flags=re.IGNORECASE,
    ):
        """
        Uses a regex pattern to parse LLM output. Returns a Label or None of failure.

        :param pattern_format: A regex pattern with optional LABEL and TERM placeholders
            that will be replaced inline with values from the Instance's answer choices.
        :param match_label: Whether to regex match against the label value. Takes
            precedence over match_term, but both can be True.
        :param match_term: Whether to regex match against the term value. match_label
            takes precedence over this, but both can be True.
        :param comparator: Comparator between extracted label/term and associated
            label/term as written in the Instance answer choices.
        :param flags: Flags to pass to re.search(), if any.
        """
        self.pattern_format = pattern_format
        self.match_label = match_label
        self.match_term = match_term
        self.comparator = comparator
        self.flags = flags

    def __call__(
        self,
        generated_text: str,
        instance: Instance,
        *args,
        **kwargs,
    ) -> Optional[Label]:
        for label, term in instance.answer_choices.items():
            pattern = self.pattern_format.replace("LABEL", label).replace("TERM", term)
            if self.flags is None:
                match = re.search(pattern, generated_text)
            else:
                match = re.search(pattern, generated_text, flags=self.flags)
            if match is not None:
                if self.match_label and self.comparator(match.group(1), label):
                    return label
                if self.match_term and self.comparator(match.group(1), term):
                    return label
        return None


class ExactMatchLLMOutputParser(LLMOutputParser):
    def __call__(
        self,
        generated_text: str,
        instance: Instance,
        *args,
        **kwargs,
    ) -> Optional[Label]:
        """
        Returns the exactly matching label in the generated_text (barring whitespace)
        or None if the text is not an exact match for an Instance answer choice Label.
        """
        for label in instance.answer_choices:
            if generated_text.strip() == label:
                return label
        return None


class JSONLLMOutputParser(LLMOutputParser):
    def __init__(
        self,
        schema_key: str,
        pattern: str = r"({.*?})",  # NOTE: Doesn't catch JSON objects w/ nested dicts.
        match_label: bool = True,
        match_term: bool = True,
        comparator: Callable[[str, str], bool] = lambda x, y: x.lower() == y.lower(),
        flags=re.IGNORECASE,
    ):
        """
        Extracts JSON objects from generated_text, checking whether the value at the
        schema_key in each object corresponds to a label/term. Returns None on failure.

        :param schema_key: The key into the JSON object containing the answer Label.
        :param pattern: A regex pattern to extract JSON objects from generated_text
            that may also include other text.
        :param match_label: Whether the value corresponding to the schema key in the
            JSON object should match against the label value. Takes precedence over
            match_term, but both can be True.
        :param match_term: Whether the value corresponding to the schema key in the
            JSON object should match against the term value. match_label takes
            precedence over this, but both can be True.
        :param comparator: Comparator between extracted label/term and associated
            label/term as written in the Instance answer choices.
        :param flags: Flags to pass to re.compile(), if any.
        """
        self.schema_key = schema_key
        if flags is None:
            self.pattern = re.compile(pattern)
        else:
            self.pattern = re.compile(pattern, flags=flags)
        self.match_label = match_label
        self.match_term = match_term
        self.comparator = comparator

    def __call__(
        self,
        generated_text: str,
        instance: Instance,
        *args,
        **kwargs,
    ) -> Optional[Label]:
        for string in [generated_text, *self.pattern.findall(generated_text)]:
            try:
                value = json.loads(string, **kwargs)[self.schema_key]
                for label, term in instance.answer_choices.items():
                    if self.match_label and self.comparator(value, label):
                        return label
                    if self.match_term and self.comparator(value, term):
                        return label
            except (AttributeError, KeyError, TypeError, json.decoder.JSONDecodeError):
                continue
        return None


class SimpleLLMOutputParser(LLMOutputParser):
    # NOTE: These are in approximate descending order of confidence in the pattern.
    default_sub_parsers: list[LLMOutputParser] = [
        ExactMatchLLMOutputParser(),
        JSONLLMOutputParser("answer"),
        PatternMatchLLMOutputParser(r'"?(LABEL)"?\s*:\s*"?TERM"?', match_term=False),
        PatternMatchLLMOutputParser(r'Answer:\s*"?(LABEL|TERM)"?'),
        PatternMatchLLMOutputParser(r'{\s*"?answer"?\s*:\s*"?(LABEL|TERM)"?\s*}'),
        PatternMatchLLMOutputParser(r'{\s*"?answer"?\s*:\s*"(LABEL|TERM)"\s*}?'),
        PatternMatchLLMOutputParser(
            r'{\s*"?answer"?\s*:\s*"?(LABEL)\s*:\s*TERM"?\s*}?',
            match_term=False,
        ),
        PatternMatchLLMOutputParser(r'answer is:?\s*"?(LABEL|TERM)"?'),
        PatternMatchLLMOutputParser(r'^\s*"?(LABEL|TERM)"?\n'),
    ]

    def __init__(self, sub_parsers: list[LLMOutputParser] = None):
        """
        Parses LLM output using sub-parsers. These are checked in order, and so should
        be given in descending order of confidence in their ability to extract a valid
        label from the generated text. Uses SimpleLLMOutputParser.default_sub_parsers
        if sub_parsers is None.

        :param sub_parsers: Optional list of sub-parsers to call, in order.
        """
        self.parsers = self.default_sub_parsers if sub_parsers is None else sub_parsers

    def __call__(
        self,
        generated_text: str,
        instance: Instance,
        *args,
        **kwargs,
    ) -> Optional[Label]:
        """Returns the Label of the first successful sub-parser, or None on failure."""
        for parser in self.parsers:
            label = parser(generated_text, instance, *args, **kwargs)
            if label is not None:
                return label
        return None
